Gun gun;
boolean[] keys = new boolean[256];
ArrayList<Balloon> balloons;
ArrayList<Bullet> bullets;
int level = 1;
int balloonCount = 0;

void setup() {
  fullScreen();
  background(0);
  gun = new Gun(width/2, height/2, "anar's favorite gun");
  balloons = new ArrayList<Balloon>();
  bullets = new ArrayList<Bullet>();
  spawnBalloons();
}

void draw() {
  background(0);
  gun.handleMovement(keys);
  gun.pointTowardsMouse();
  gun.drawGun();
  
  // Update and draw balloons
  for (int i = balloons.size() - 1; i >= 0; i--) {
    Balloon b = balloons.get(i);
    b.update(level);
    b.display();
    if (b.isOffScreen()) {
      balloons.remove(i);
    }
  }
  
  // Update and draw bullets
  for (int i = bullets.size() - 1; i >= 0; i--) {
    Bullet bullet = bullets.get(i);
    bullet.update();
    bullet.display();
    if (bullet.isOffScreen()) {
      bullets.remove(i);
      continue;
    }
    // Check collision with balloons
    for (int j = balloons.size() - 1; j >= 0; j--) {
      Balloon b = balloons.get(j);
      if (bullet.collidesWith(b)) {
        b.takeDamage();
        bullets.remove(i);
        if (b.isDead()) {
          balloons.remove(j);
        }
        break;
      }
    }
  }
  
  // Check if all balloons are gone - advance level
  if (balloons.size() == 0) {
    level++;
    spawnBalloons();
  }
  
  // Display level
  fill(255);
  textSize(24);
  text("Level: " + level, 20, 30);
  text("Balloons: " + balloons.size(), 20, 60);
}

void spawnBalloons() {
  int numBalloons = 3 + level;
  for (int i = 0; i < numBalloons; i++) {
    float x = random(100, width - 100);
    float y = random(100, height - 100);
    int strength = int(random(1, min(4, level)));
    balloons.add(new Balloon(x, y, strength));
  }
}

void keyPressed() {
  if (keyCode < 256) {
    keys[keyCode] = true;
  }
  if (key == 'f' || key == 'F') {
    gun.randomizeSeed();
  }
  if (key == ' ') {
    bullets.add(gun.createBullet());
  }
}

void keyReleased() {
  if (keyCode < 256) {
    keys[keyCode] = false;
  }
}

class Gun {
  float xpos, ypos;
  float angle = 0;
  int seed;
  float barrelLength;
  float barrelGirth = 4;
  float handleLength = 45;
  float handleSlant = 2; // radians, ~17 degrees
  color metalGrey = color(100, 100, 110); // metallic grey
  float speed = 5;
  
  // Firemode and magazine
  int maxAmmo = 30;
  int currentAmmo = 30;
  int fireMode = 0; // 0=single, 1=burst, 2=auto
  String[] fireModeNames = {"SINGLE", "BURST", "AUTO"};
  int burstCount = 0;
  int burstSize = 3;
  int fireCounter = 0;
  int autoFireDelay = 5;
  int burstFireDelay = 3;
  Gun(float x, float y, String gunName) {
    this.seed = gunName.hashCode();
    this.xpos = x;
    this.ypos = y;
    generateBarrel();
  }

  void generateBarrel() {
    // Barrel length determined by seed (between 200 and 400)
    randomSeed(seed);
    this.barrelLength = random(200, 400);
    // Barrel girth determined by seed (between 12 and 20)
    this.barrelGirth = random(12, 20);
  }

  void randomizeSeed() {
    this.seed = (int)random(Integer.MAX_VALUE);
    generateBarrel();
  }

  void toggleFireMode() {
    fireMode = (fireMode + 1) % 3;
    burstCount = 0;
  }

  void reload() {
    currentAmmo = maxAmmo;
    burstCount = 0;
    fireCounter = 0;
  }

  void fire() {
    if (currentAmmo <= 0) return;
    
    if (fireMode == 0) { // SINGLE
      if (fireCounter > 0) return;
      currentAmmo--;
      bullets.add(createBullet());
      fireCounter = 10; // cooldown
    } else if (fireMode == 1) { // BURST
      if (fireCounter > 0) {
        fireCounter--;
        return;
      }
      if (burstCount < burstSize && currentAmmo > 0) {
        currentAmmo--;
        bullets.add(createBullet());
        burstCount++;
        fireCounter = burstFireDelay;
      }
    } else if (fireMode == 2) { // AUTO
      if (fireCounter > 0) {
        fireCounter--;
        return;
      }
      if (currentAmmo > 0) {
        currentAmmo--;
        bullets.add(createBullet());
        fireCounter = autoFireDelay;
      }
    }
  }

  void updateFire() {
    if (fireCounter > 0) fireCounter--;
    if (fireMode == 1 && burstCount >= burstSize) {
      burstCount = 0;
    }
  }
  void handleMovement(boolean[] keys) {
    if (keys['w'] || keys['W']) ypos -= speed;
    if (keys['s'] || keys['S']) ypos += speed;
    if (keys['a'] || keys['A']) xpos -= speed;
    if (keys['d'] || keys['D']) xpos += speed;
  }

  void pointTowardsMouse() {
    // Calculate angle toward mouse
    angle = atan2(mouseY - ypos, mouseX - xpos);
  }

  void drawGun() {
    pushMatrix();
    translate(xpos, ypos);
    rotate(angle);
    
    fill(metalGrey);
    stroke(metalGrey);
    noStroke();
    
    // Draw handle (angled downward) - twice as thick
    pushMatrix();
    strokeWeight(16);
    stroke(metalGrey);
    line(0, 0, handleLength * cos(handleSlant), handleLength * sin(handleSlant));
    popMatrix();
    
    // Draw barrel as rectangle
    fill(metalGrey);
    rect(0, -barrelGirth/2 - 8, barrelLength, barrelGirth);
    
    popMatrix();
  }
  
  Bullet createBullet() {
    float bulletX = xpos + cos(angle) * barrelLength;
    float bulletY = ypos + sin(angle) * barrelLength;
    float bulletVelX = cos(angle) * 8;
    float bulletVelY = sin(angle) * 8;
    return new Bullet(bulletX, bulletY, bulletVelX, bulletVelY);

    randomSeed(frameCount + currentAmmo);
    
    // Procedural bullet properties
    float size = random(3, 10);
    float speed = random(4, 12);
    int trajectory = int(random(3)); // 0=straight, 1=sine, 2=freefalling
    color bulletColor = color(random(150, 255), random(150, 255), random(50, 150));
    
    bulletVelX = cos(angle) * speed;
    bulletVelY = sin(angle) * speed;
    
    return new Bullet(bulletX, bulletY, bulletVelX, bulletVelY, size, bulletColor, trajectory);
  }
}
class Balloon {
  float xpos, ypos;
  float velX, velY;
  int strength; // number of layers
  float baseRadius = 30;
  color[] layerColors = {color(255, 50, 50), color(255, 150, 50), color(255, 255, 50)};
  
  Balloon(float x, float y, int str) {
    this.xpos = x;
    this.ypos = y;
    this.strength = str;
    this.velX = random(-2, 2);
    this.velY = random(-2, 2);
  }
  
  void update(int level) {
    // Increase speed based on level
    float speedMultiplier = 1 + (level * 0.3);
    xpos += velX * speedMultiplier;
    ypos += velY * speedMultiplier;
    
    // Bounce off walls
    if (xpos - getRadius() < 0 || xpos + getRadius() > width) {
      velX *= -1;
    }
    if (ypos - getRadius() < 0 || ypos + getRadius() > height) {
      velY *= -1;
    }
    
    xpos = constrain(xpos, getRadius(), width - getRadius());
    ypos = constrain(ypos, getRadius(), height - getRadius());
  }
  
  void display() {
    // Draw layers from inside out
    for (int i = strength - 1; i >= 0; i--) {
      float layerRadius = baseRadius + (i * 15);
      fill(layerColors[i % layerColors.length]);
      stroke(100);
      strokeWeight(2);
      circle(xpos, ypos, layerRadius * 2);
    }
  }
  
  float getRadius() {
    return baseRadius + ((strength - 1) * 15);
  }
  
  void takeDamage() {
    strength--;
  }
  
  boolean isDead() {
    return strength <= 0;
  }
  
  boolean isOffScreen() {
    return xpos < -100 || xpos > width + 100 || ypos < -100 || ypos > height + 100;
  }
}

class Bullet {
  float xpos, ypos;
  float velX, velY;
  float size = 5;
  
  Bullet(float x, float y, float vx, float vy) {
    this.xpos = x;
    this.ypos = y;
    this.velX = vx;
    this.velY = vy;
    this.bulletColor = color(255, 255, 150);
    this.trajectory = 0;
  }
  
  color bulletColor;
  int trajectory; // 0=straight, 1=sine wave, 2=freefalling
  float wavePhase = 0;
  float gravity = 0.15;
  
  Bullet(float x, float y, float vx, float vy, float s, color c, int t) {
    this.xpos = x;
    this.ypos = y;
    this.velX = vx;
    this.velY = vy;
    this.size = s;
    this.bulletColor = c;
    this.trajectory = t;
  }
  
  void update() {
    xpos += velX;
    ypos += velY;
  }
  
  
  void update() {
    if (trajectory == 0) { // Straight
      xpos += velX;
      ypos += velY;
    } else if (trajectory == 1) { // Sine wave
      xpos += velX;
      ypos += velY + sin(wavePhase) * 2;
      wavePhase += 0.1;
    } else if (trajectory == 2) { // Freefalling
      xpos += velX;
      ypos += velY;
      velY += gravity;
    }
  }
  
  void display() {
    fill(bulletColor);
    stroke(red(bulletColor) * 0.8, green(bulletColor) * 0.8, blue(bulletColor) * 0.8);
    strokeWeight(1);
    circle(xpos, ypos, size);
  }
  boolean isOffScreen() {
    return xpos < 0 || xpos > width || ypos < 0 || ypos > height;
  }
  
  boolean collidesWith(Balloon b) {
    float distance = dist(xpos, ypos, b.xpos, b.ypos);
    return distance < size/2 + b.getRadius();
  }
}
